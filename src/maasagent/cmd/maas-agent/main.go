package main

/*
	Copyright 2023 Canonical Ltd.  This software is licensed under the
	GNU Affero General Public License version 3 (see the file LICENSE).
*/

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"
	"time"

	backoff "github.com/cenkalti/backoff/v4"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/converter"
	"golang.org/x/sync/errgroup"
	"gopkg.in/yaml.v3"

	wf "maas.io/core/src/maasagent/internal/workflow"
	wflog "maas.io/core/src/maasagent/internal/workflow/log"
	"maas.io/core/src/maasagent/internal/workflow/worker"
	"maas.io/core/src/maasagent/pkg/workflow/codec"
)

const (
	TemporalPort = 5271
)

// config represents a neccessary set of configuration options for MAAS Agent
type config struct {
	MAASUUID       string   `yaml:"maas_uuid"`
	SystemID       string   `yaml:"system_id"`
	Secret         string   `yaml:"secret"`
	LogLevel       string   `yaml:"log_level"`
	Controllers    []string `yaml:"controllers,flow"`
	ImageCacheSize int64    `yaml:"image_cache_size"`
}

func Run() int {
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})

	cfg, err := getConfig()
	if err != nil {
		log.Error().Err(err).Send()
		return 1
	}

	// Encryption Codec required for Temporal Workflow's payload encoding
	codec, err := codec.NewEncryptionCodec([]byte(cfg.Secret))
	if err != nil {
		log.Error().Err(err).Msg("Encryption codec setup failed")
		return 1
	}

	var logLevel zerolog.Level

	logLevel, err = zerolog.ParseLevel(cfg.LogLevel)
	if err != nil || logLevel == zerolog.NoLevel {
		logLevel = zerolog.InfoLevel
	}

	zerolog.SetGlobalLevel(logLevel)

	log.Info().Msg(fmt.Sprintf("Logger is configured with log level %q", logLevel.String()))

	clientBackoff := backoff.NewExponentialBackOff()
	clientBackoff.MaxElapsedTime = 60 * time.Second

	client, err := backoff.RetryWithData(
		func() (client.Client, error) {
			return client.Dial(client.Options{
				// TODO: fallback retry if Controllers[0] is unavailable
				HostPort: fmt.Sprintf("%s:%d", cfg.Controllers[0], TemporalPort),
				Identity: fmt.Sprintf("%s@agent:%d", cfg.SystemID, os.Getpid()),
				Logger:   wflog.NewZerologAdapter(log.Logger),
				DataConverter: converter.NewCodecDataConverter(
					converter.GetDefaultDataConverter(),
					codec,
				),
			})
		}, clientBackoff,
	)

	if err != nil {
		log.Error().Err(err).Msg("Temporal client error")
		return 1
	}

	httpProxies := wf.NewHTTPProxyConfigurator()
	if cfg.ImageCacheSize > 0 {
		httpProxies.SetCacheSize(cfg.ImageCacheSize)
	}

	workerPool := worker.NewWorkerPool(cfg.SystemID, client,
		worker.WithAllowedWorkflows(map[string]interface{}{
			"check-ip":    wf.CheckIP,
			"power-on":    wf.PowerOn,
			"power-off":   wf.PowerOff,
			"power-query": wf.PowerQuery,
			"power-cycle": wf.PowerCycle,
		}), worker.WithAllowedActivities(map[string]interface{}{
			"power": wf.PowerActivity,
		}),
		worker.WithControlPlaneTaskQueueName("region"),
		worker.WithMainWorkerTaskQueueSuffix("agent:main"),
		worker.WithConfigureWorkerPoolWorkflowName("configure-agent"),
		worker.WithHTTPProxyConfigurator(httpProxies),
	)

	workerPoolBackoff := backoff.NewExponentialBackOff()
	workerPoolBackoff.MaxElapsedTime = 60 * time.Second

	err = backoff.Retry(workerPool.Start, workerPoolBackoff)
	if err != nil {
		log.Error().Err(err).Msg("Temporal worker pool failure")
		return 1
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	errGroup, ctx := errgroup.WithContext(ctx)

	errGroup.Go(func() error {
		err := workerPool.Configure(ctx)
		if err != nil {
			log.Error().Err(err).Msg("Temporal worker pool configuration failure")
			return err
		}

		return <-workerPool.Error()
	})

	errGroup.Go(func() error {
		// loop so we may restart upon reconfiguration
		for {
			select {
			case <-ctx.Done():
				return nil
			case <-httpProxies.Ready():
				log.Info().Msg("Starting HTTP proxy")

				err := httpProxies.Proxies.Listen(ctx)
				if err != nil && !errors.Is(err, http.ErrServerClosed) {
					return err
				}
			}
		}
	})

	log.Info().Msg("Service MAAS Agent started")

	sigC := make(chan os.Signal, 2)

	signal.Notify(sigC, syscall.SIGTERM, syscall.SIGINT)

	groupErrors := make(chan error)

	go func() {
		groupErrors <- errGroup.Wait()
	}()

	select {
	case err := <-groupErrors:
		log.Err(err).Msg("a service failed to execute")
		return 1
	case <-sigC:
		return 0
	}
}

// getConfig reads MAAS Agent YAML configuration file
// TODO: agent.yaml config is generated by rackd, however this behaviour
// should be changed when MAAS Agent will be a standalone service, not managed
// by the Rack Controller.
func getConfig() (*config, error) {
	fname := os.Getenv("MAAS_AGENT_CONFIG")
	if fname == "" {
		fname = "/etc/maas/agent.yaml"
	}

	data, err := os.ReadFile(filepath.Clean(fname))
	if err != nil {
		return nil, fmt.Errorf("configuration error: %w", err)
	}

	cfg := &config{}

	err = yaml.Unmarshal([]byte(data), cfg)
	if err != nil {
		return nil, fmt.Errorf("configuration error: %w", err)
	}

	return cfg, nil
}

func main() {
	os.Exit(Run())
}
